<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Gaelen Guzman">
<meta name="dcterms.date" content="2025-01-09">

<title>Maintenance Instructions</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="MaintenanceInstructions_files/libs/clipboard/clipboard.min.js"></script>
<script src="MaintenanceInstructions_files/libs/quarto-html/quarto.js"></script>
<script src="MaintenanceInstructions_files/libs/quarto-html/popper.min.js"></script>
<script src="MaintenanceInstructions_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="MaintenanceInstructions_files/libs/quarto-html/anchor.min.js"></script>
<link href="MaintenanceInstructions_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="MaintenanceInstructions_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="MaintenanceInstructions_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="MaintenanceInstructions_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="MaintenanceInstructions_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Maintenance Instructions</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Gaelen Guzman </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 9, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="site-organization" class="level2">
<h2 class="anchored" data-anchor-id="site-organization">Site Organization</h2>
<p>I’ve done my best to make the site organization logical, but really only the next person to try to update this site can be the judge on whether I succeeded in that…</p>
<p>Under the “IndividualStudies” folder are the .qmd files that define the preparation of each corresponding .html page. The data going into these .qmd files is stored under the “DataTables” subfolder. Under the “LipidProbe” folder are the .qmd files that define the pages on each individual probe. Much of the information is copied between the two sets of pages, so be careful when making changes to one, as corresponding changes should be made elsewhere!</p>
<p>The _quarto.yml page is described further below, but here it should be mentioned that it will need to be modified to add pages to the site, as it defines the linking structure throughout the whole site.</p>
</section>
<section id="maintenance" class="level2">
<h2 class="anchored" data-anchor-id="maintenance">Maintenance</h2>
<section id="basic-overview" class="level3">
<h3 class="anchored" data-anchor-id="basic-overview">Basic overview</h3>
<p>This site was built using Quarto. This is a form of R Markdown that is highly documented, and one can learn how to modify this site here: <a href="https://quarto.org/docs/websites" target="_blank">https://quarto.org/docs/websites</a>.</p>
<p>The overarching formatting of the site is controlled within the _quarto.yml file. Here one can update the site theme from the array of <a href="https://bootswatch.com/" target="_blank">Bootswatch</a> themes, or if you’re feeling ambitious you can design your own theme.</p>
<p>When making updates to the site, one first edits/makes a file, then you use the Bash command “quarto render”. This will update the site directory within the _site folder. There are a lot of ways to do the editing, but it’s nicest to use the IDE Visual Studio Code because there’s a terminal in-window and you can see nice previews of what the site will look like without leaving the program.</p>
</section>
<section id="github-repository" class="level3">
<h3 class="anchored" data-anchor-id="github-repository">GitHub repository</h3>
<p>After changes are made to the .qmd files and then rendered, the changes can then be pushed to the GitHub repository: <a href="mailto:git@github.com:gaelenDG/LipidInteractomics_Website.git" class="email">git@github.com:gaelenDG/LipidInteractomics_Website.git</a>. Netlify will pull the changes and automatically deploy the updated site! See site owners for Netlify login information and .git access.</p>
<p>Cloning the GitHub repository should be sufficient for gaining access to all of the files in this website - though collaborators will need to be added manually by Gaelen, the repository administrator. More details will go here once a more formal pull request workflow is in place!</p>
</section>
<section id="quarto-formatting" class="level3">
<h3 class="anchored" data-anchor-id="quarto-formatting">Quarto formatting</h3>
<p>I have found that Quarto is highly documented and it’s pretty easy to figure out how to format or change the way things look (if all else fails, ask ChatGPT and you usually get a pretty good answer).</p>
<p>As a reference to help get you started, I very much appreciated <a href="https://blog.posertinlab.com/posts/2023-06-09-writing-a-dissertation-in-quarto/" target="_blank">this blog post</a> by Richard Posert about using Quarto.</p>
<p>I honestly get the most confused when it comes to formatting the _quarto.yml file because there aren’t many fully-fleshed examples out there for all the options. This is where I’ve (embarrassingly) leaned on ChatGPT for help – it’s not always right, but it’s usually close enough that you can make it work properly anyways.</p>
<p>If you want to add a page, you need to make a new .qmd file in the proper subfolder and render it as an .html file (conveniently, the Preview button in VS Code does that for you, but you can use whatever IDE you want). Then you need to add two lines to the .yml file so that the page is properly linked on the sidebar or navbar (first the href to denote the file path to the .html file, then the text to display on the page) – if you don’t add these, the page will remain unlinked and you’ll need to know the whole URL to find it (like this maintenance page).</p>
<p>If your data looks at all like <a href="https://lipidinteractomicsrepository.netlify.app/individualstudies/at_2025" target="_blank">Alix’s</a> or <a href="https://lipidinteractomicsrepository.netlify.app/individualstudies/sf_2024" target="_blank">Scotty’s</a>, the ggplot functions I built in the ggplot_styles.R file will apply. Call the RankedOrderPlotStandard(), VolcanoPlotStandardized(), and MAStandard() functions to produce these plots with the same standardized formatting. On that note, you can alter the ggplot_styles.R file to change the standardized formatting.</p>
<p>There are a ton of things you can do within html divs, but I haven’t dipped my toes in those yet - use these to finely adjust how elements of each page look.</p>
<p>In order to make sure the author information is identical on all appropriate pages, I made an “include” folder with each study included thus far. This enables you to call the same study information on each probe/study page without worrying that they’re somehow different.</p>
</section>
<section id="shiny-app" class="level3">
<h3 class="anchored" data-anchor-id="shiny-app">Shiny app</h3>
<p>The Shiny app embedded in the iframe in the <a href="LipidProbe/EnrichedHitsComparison.qmd">Probe vs Probe Comparisons</a> markdown is defined within “/ShinyApps/LipidInteractomics_ShinyApp”. In order to add new studies to this, you will need to update the .csv file saved in Chunk #1 of “LipidProbe/EnrichedHitsComparison.qmd”. Save the .csv, make sure it updates in the Shiny App directory, and re-deploy the Shiny App to <a href="shinyapps.io">shinyapps.io</a>. Gaelen will have to manage the permissions to make this possible for other users – stay tuned for updates here.</p>
</section>
</section>
<section id="step-by-step-instructions-for-adding-a-new-study" class="level2">
<h2 class="anchored" data-anchor-id="step-by-step-instructions-for-adding-a-new-study">Step-by-step instructions for adding a new study</h2>
<p>(Assumes that you’re adding a new study which utilized TMT and Frank’s FragPipe data analysis pipeline. Anything else will have to be somewhat custom made.)</p>
<ol type="1">
<li><p>Duplicate the template file under the /StudyInformation_includes folder, populate each section with the appropriate details about the study being added. This “include” file will be linked to the actual data pages and allows for a single point to edit the details across all the pages.</p></li>
<li><p>Duplicate the template file under the /IndividualStudies folder, edit “include” link to point to the new file made in Step 1.</p>
<ul>
<li>Copy full dataset to the /IndividualStudies/DataTables folder with an appropriate name.</li>
<li>Edit the setup/data wrangling R chunk to open and prepare the data – make sure the read_csv() call points to the location of the dataset being added. If needed, adjust the order of lipid probes depicted under the factor(pull()) function call – change the values of the levels vector to reflect the probes (the default is simply alphabetical)</li>
<li>Don’t yet adjust the Gene Ontology sections - we’ll return to this in Step 5.</li>
</ul></li>
<li><p>If new study utilizes new lipid probes, make as many duplicates as appropriate of the template file under the /LipidProbe folder (i.e., if there are two lipid probes analyzed in the study at hand.)</p>
<ul>
<li>Prepare individual copies of the dataset filtered for each lipid probe, place them in the /LipidProbe/Datasets folder (I know that the /Datasets folder doesn’t match the /DataTable folder, I’ll work on fixing that someday).</li>
<li>Make sure the cell type referenced is accurate, link to the appropriate “include” to add the correct study details.</li>
<li>Edit the setup/data wrangling R chunk to open and prepare the data.</li>
<li>Adjust the plotting function calls.</li>
<li>Again, we’ll do the Gene Ontology section in step 5.</li>
</ul></li>
<li><p>If the new study repeats an analysis of a lipid probe in a new cell type, add the dataset to a new section to the appropriate LipidProbe .qmd file</p>
<ul>
<li>For example, the Sphingosine probe was used in both Huh7 cells and HeLa – use this file as a reference to adjust an existing page.</li>
</ul></li>
<li><p>To prepare the gene ontology plots for the new study, first make the appropriate plot files using the script under the /Resources/Re-run_GO_plots.R file.</p>
<ul>
<li>See the instructions in the doc string at the top of the file.</li>
<li>Currently, the sections in the file are organized so that each study and each lipid probe within the study are together in big blocks.</li>
<li>Add a new block for the new data, use read_csv() to open each respective dataframe and apply the three CC, MF, and BP plotting functions to each part of the new data.</li>
<li>The plotting functions will save new files to the designated folders – make sure the filenames are unique and easily recognizable (e.g.&nbsp;“<strong>1-10FA_SF_2024_</strong>CC-DOTplot.html”), you’ll need them shortly</li>
<li>Now go back to the .qmd files under /LipidProbe and /IndividualStudies and make sure the Gene Ontology references point to the correct new files - pay attention to the CC, MF, BP types!</li>
</ul></li>
<li><p>Update “Search by protein” page</p>
<ul>
<li>Add new data to the /SearchByProtein/combinedProbeDatasets_TMT.csv file with rbind().</li>
<li>Add study DOI and short name to the case_when() call.</li>
</ul></li>
<li><p>Update Shiny App on “Probe vs Probe Comparisons” page</p>
<ul>
<li>This will require access to the ShinyApps.io account.</li>
<li>Copy the new version of the combinedProbeDatasets_TMT.csv file to the /ShinyApps/LipidInteractomics_ShinyApp folder.</li>
<li>Make sure the app still works with the new dataset, if it does, redeploy!</li>
</ul></li>
<li><p>Finally, we need to update the _quarto.yml file so that the new .qmd files are organized under the correct lipid class</p>
<ul>
<li>e.g.&nbsp;if the new probe is a sphingolipid, make sure to place its link there</li>
<li>If the new probes are a distinct class, make a new category of probe (use the existing categories as a template)</li>
</ul></li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>